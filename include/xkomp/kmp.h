#ifndef __KMP_H__
# define __KMP_H__

# include <stdint.h>

typedef char kmp_int8;
typedef unsigned char kmp_uint8;
typedef short kmp_int16;
typedef unsigned short kmp_uint16;
typedef int kmp_int32;
typedef unsigned int kmp_uint32;
#define KMP_INT32_SPEC "d"
#define KMP_UINT32_SPEC "u"
#ifndef KMP_STRUCT64
typedef  int64_t  kmp_int64;
typedef uint64_t kmp_uint64;
#define KMP_INT64_SPEC "I64d"
#define KMP_UINT64_SPEC "I64u"
#else
struct kmp_struct64 {
  kmp_int32 a, b;
};
typedef struct kmp_struct64 kmp_int64;
typedef struct kmp_struct64 kmp_uint64;
/* Not sure what to use for KMP_[U]INT64_SPEC here */
#endif

/*!
Values for bit flags used in the ident_t to describe the fields.
*/
enum {
  /*! Use trampoline for internal microtasks */
  KMP_IDENT_IMB = 0x01,
  /*! Use c-style ident structure */
  KMP_IDENT_KMPC = 0x02,
  /* 0x04 is no longer used */
  /*! Entry point generated by auto-parallelization */
  KMP_IDENT_AUTOPAR = 0x08,
  /*! Compiler generates atomic reduction option for kmpc_reduce* */
  KMP_IDENT_ATOMIC_REDUCE = 0x10,
  /*! To mark a 'barrier' directive in user code */
  KMP_IDENT_BARRIER_EXPL = 0x20,
  /*! To Mark implicit barriers. */
  KMP_IDENT_BARRIER_IMPL = 0x0040,
  KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0,
  KMP_IDENT_BARRIER_IMPL_FOR = 0x0040,
  KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0,

  KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140,
  KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0,

  /*! To mark a static loop in OMPT callbacks */
  KMP_IDENT_WORK_LOOP = 0x200,
  /*! To mark a sections directive in OMPT callbacks */
  KMP_IDENT_WORK_SECTIONS = 0x400,
  /*! To mark a distribute construct in OMPT callbacks */
  KMP_IDENT_WORK_DISTRIBUTE = 0x800,
  /*! Atomic hint; bottom four bits as omp_sync_hint_t. Top four reserved and
      not currently used. If one day we need more bits, then we can use
      an invalid combination of hints to mean that another, larger field
      should be used in a different flag. */
  KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000,
  KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000,
  KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000,
  KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000,
  KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000,
  KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000
};

/*!
 * The ident structure that describes a source location.
 */
typedef struct ident {
  kmp_int32 reserved_1; /**<  might be used in Fortran; see above  */
  kmp_int32 flags; /**<  also f.flags; KMP_IDENT_xxx flags; KMP_IDENT_KMPC
                      identifies this union member  */
  kmp_int32 reserved_2; /**<  not really used in Fortran any more; see above */
#if USE_ITT_BUILD
/*  but currently used for storing region-specific ITT */
/*  contextual information. */
#endif /* USE_ITT_BUILD */
  kmp_int32 reserved_3; /**< source[4] in Fortran, do not use for C++  */
  char const *psource; /**< String describing the source location.
                       The string is composed of semi-colon separated fields
                       which describe the source file, the function and a pair
                       of line numbers that delimit the construct. */
  // Returns the OpenMP version in form major*10+minor (e.g., 50 for 5.0)
  kmp_int32 get_openmp_version() {
    return (((flags & KMP_IDENT_OPENMP_SPEC_VERSION_MASK) >> 24) & 0xFF);
  }
} ident_t;

typedef kmp_int32 (*kmp_routine_entry_t)(kmp_int32, void *);

typedef union kmp_cmplrdata {
  kmp_int32 priority; /**< priority specified by user for the task */
  kmp_routine_entry_t
      destructors; /* pointer to function to invoke deconstructors of
                      firstprivate C++ objects */
  /* future data */
} kmp_cmplrdata_t;

typedef struct kmp_task { /* GEH: Shouldn't this be aligned somehow? */
    void *shareds; /**< pointer to block of pointers to shared vars   */
    kmp_routine_entry_t
        routine; /**< pointer to routine to call for executing task */
    kmp_int32 part_id; /**< part id for the task                          */
    kmp_cmplrdata_t data1; /* Two known optional additions: destructors and priority */
    kmp_cmplrdata_t data2; /* Process destructors first, priority second */
    /* future data */
    /*  private vars  */
} kmp_task_t;

typedef void (*kmpc_micro)(kmp_int32 *global_tid, kmp_int32 *bound_tid, ...);

enum sched_type {
  kmp_sch_lower = 32, /**< lower bound for unordered values */
  kmp_sch_static_chunked = 33,
  kmp_sch_static = 34, /**< static unspecialized */
  kmp_sch_dynamic_chunked = 35,
  kmp_sch_guided_chunked = 36, /**< guided unspecialized */
  kmp_sch_runtime = 37,
  kmp_sch_auto = 38, /**< auto */
  kmp_sch_trapezoidal = 39,
  /* accessible only through KMP_SCHEDULE environment variable */
  kmp_sch_static_greedy = 40,
  kmp_sch_static_balanced = 41,
  /* accessible only through KMP_SCHEDULE environment variable */
  kmp_sch_guided_iterative_chunked = 42,
  kmp_sch_guided_analytical_chunked = 43,

  kmp_sch_static_steal =
      44, /**< accessible only through KMP_SCHEDULE environment variable */

  /* accessible only through KMP_SCHEDULE environment variable */
  kmp_sch_upper = 45, /**< upper bound for unordered values */

  kmp_ord_lower = 64, /**< lower bound for ordered values, must be power of 2 */
  kmp_ord_static_chunked = 65,
  kmp_ord_static = 66, /**< ordered static unspecialized */
  kmp_ord_dynamic_chunked = 67,
  kmp_ord_guided_chunked = 68,
  kmp_ord_runtime = 69,
  kmp_ord_auto = 70, /**< ordered auto */
  kmp_ord_trapezoidal = 71,
  kmp_ord_upper = 72, /**< upper bound for ordered values */

#if OMP_40_ENABLED
  /* Schedules for Distribute construct */
  kmp_distribute_static_chunked = 91, /**< distribute static chunked */
  kmp_distribute_static = 92,         /**< distribute static unspecialized */
#endif

  /*
   * For the "nomerge" versions, kmp_dispatch_next*() will always return
   * a single iteration/chunk, even if the loop is serialized.  For the
   * schedule types listed above, the entire iteration vector is returned
   * if the loop is serialized.  This doesn't work for gcc/gcomp sections.
   */
  kmp_nm_lower = 160, /**< lower bound for nomerge values */

  kmp_nm_static_chunked =
      (kmp_sch_static_chunked - kmp_sch_lower + kmp_nm_lower),
  kmp_nm_static = 162, /**< static unspecialized */
  kmp_nm_dynamic_chunked = 163,
  kmp_nm_guided_chunked = 164, /**< guided unspecialized */
  kmp_nm_runtime = 165,
  kmp_nm_auto = 166, /**< auto */
  kmp_nm_trapezoidal = 167,

  /* accessible only through KMP_SCHEDULE environment variable */
  kmp_nm_static_greedy = 168,
  kmp_nm_static_balanced = 169,
  /* accessible only through KMP_SCHEDULE environment variable */
  kmp_nm_guided_iterative_chunked = 170,
  kmp_nm_guided_analytical_chunked = 171,
  kmp_nm_static_steal =
      172, /* accessible only through OMP_SCHEDULE environment variable */

  kmp_nm_ord_static_chunked = 193,
  kmp_nm_ord_static = 194, /**< ordered static unspecialized */
  kmp_nm_ord_dynamic_chunked = 195,
  kmp_nm_ord_guided_chunked = 196,
  kmp_nm_ord_runtime = 197,
  kmp_nm_ord_auto = 198, /**< auto */
  kmp_nm_ord_trapezoidal = 199,
  kmp_nm_upper = 200,              /**< upper bound for nomerge values */
  kmp_sch_default = kmp_sch_static /**< default scheduling algorithm */
};
#endif /* __KMP_H__ */
